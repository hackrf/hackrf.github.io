---
ID: 1007
title: "一些关于HackRF GPS重放模拟的努力以及小工具脚本"
author: jxj
date: 2014-10-27 17:55:56
post_excerpt: ""
layout: post
published: true
views:
  - "7348"
duoshuo_thread_id:
  - "1312073613704167536"
---
虽然<a href="http://sdr-x.github.io/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EGPS%E9%87%8D%E6%94%BE%E6%A8%A1%E6%8B%9F%E7%9A%84%E5%8A%AA%E5%8A%9B%E4%BB%A5%E5%8F%8A%E5%B0%8F%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/">GPS重放/模拟</a>没有获得完全成功，但一些小工具和脚本还是有用的。期间从这个“家庭自酿GPS接收机”学习了很多东西：<a href="http://www.aholme.co.uk/GPS/Main.htm">http://www.aholme.co.uk/GPS/Main.htm</a><!--more-->

<strong>**警告：请勿真正发射任何GPS信号，建议在暗室以及使用闭路电缆实验。请确保你的任何操作是合法的！后果自负！**</strong>

工具、脚本以及GPS信号仓库在此：<a href="https://github.com/JiaoXianjun/GNSS-GPS-SDR">https://github.com/JiaoXianjun/GNSS-GPS-SDR</a>

(关于一些基本的软件无线电概念，Linux操作，代码库git操作，以及软件包安装（apt-get）等，参见：<a href="http://sdr-x.github.io/rtl-sdr-rtl2832%E7%94%B5%E8%A7%86%E6%A3%92%E8%B7%9F%E8%B8%AA%E9%A3%9E%E6%9C%BAstep-by-step%E6%95%99%E7%A8%8B(tutorial%20ADS-B%20aircraft%20tracking%20by%20rtl-sdr%20rtl2832%20gr-air-modes)/">这篇文章</a>)

编译GPS接收机小工具 "gps_test" 的方法（在你把代码库拉下来之后，该小工具代码在c目录下）:
<pre class="lang:default decode:true ">cd c
make</pre>
为了make成功，你可能需要正确安装fftw库（比如用sudo apt-get install ...)，安装后库文件应当是/usr/lib/libfftw.a

<strong>一. 离线GPS C/A码 发射接收仿真方法</strong>

<strong>1.1 用"gps_test"接收Matlab脚本gps_sig_gen.m产生的GPS信号</strong>

<strong>a.</strong> 在Matlab中运行gps_sig_gen.m
<pre class="lang:default decode:true">        gps_sig_gen</pre>
得到文件gps_sig_tmp.bin

<strong>b.</strong> 运行"gps_test"看能捕获到哪些C/A码:
<pre class="lang:default decode:true ">gps_test gps_sig_tmp.bin 2.046e6 8.184e6 5000</pre>
基本算法是大范围的频域multi-bins相关搜索。

gps_sig_tmp.bin: 输入GPS信号文件，由前述gps_sig_gen.m产生

2.046e6: 载波频率（其实是中频频率）

8.184e6: 采样率

5000: 频域搜索时的最大频偏

正常情况下捕获到的C/A码和我们Matlab脚本中设置的是相同的。

<strong>1.2 用"gps_test"接收别人采集的真实的1bit量化GPS中频信号</strong>
<pre class="lang:default decode:true ">gps_test gps.samples.1bit.I.fs5456.if4092.bin 4.092e6 5.456e6 5000</pre>
gps.samples.1bit.I.fs5456.if4092.bin: 别人采集的真实的1bit量化GPS中频信号: <a href="http://www.jks.com/gps/gps.htm">http://www.jks.com/gps/gps.htm</a>

正常情况下C程序检测到的C/A码和别人这个信号采集时的正确码信息是相同的：<a href="http://www.jks.com/gps/gps.html">http://www.jks.com/gps/gps.html</a> ，
初步验证GPS软件C接收机程序的正确性。

<strong>二. 开路/空中 GPS信号收发测试</strong>

<strong>1.1 播放/发射别人采集的这个真实GPS信号gps.samples.1bit.I.fs5456.if4092.bin( <a href="http://www.jks.com/gps/gps.html">http://www.jks.com/gps/gps.html</a> )</strong>

<strong>a</strong>. Matlab中运行gps_bin1bit_log2bin.m把原来别人捕获的1bit量化文件转为HackRF需要的8bit量化文件 gps.samples.8bit.IQ.fs5456.baseband.bin

<strong>b</strong>. GNURadio中运行gps_Nottingham.grc 来发射我们转换得到的gps.samples.8bit.IQ.fs5456.baseband.bin. 同时/立刻（或稍提前）,

<strong>c</strong>. 使用rtl-sdr电视棒来捕获我们发射的信号（不知道啥叫电视棒？[<a href="http://sdr-x.github.io/rtl-sdr-rtl2832%E7%94%B5%E8%A7%86%E6%A3%92%E8%B7%9F%E8%B8%AA%E9%A3%9E%E6%9C%BAstep-by-step%E6%95%99%E7%A8%8B%28tutorial%20ADS-B%20aircraft%20tracking%20by%20rtl-sdr%20rtl2832%20gr-air-modes%29/">看这里</a>]）:
<pre class="lang:default decode:true"> rtl_sdr -g 60 -f 1575.42e6 -s 2.8e6 -n 19.2e6 rtl_2.8Msps_1575.42MHz.bin</pre>
<strong>d</strong>. Matlab里运行proc_rtl_bin_for_gps('rtl_2.8Msps_1575.42MHz.bin')来把电视棒采集的8bit文件转回我们的GPS测试程序gps_test所需的1bit文件：rtl_2.8Msps_1575.42MHz_1bit.bin

<strong>e</strong>. 运行我们的gps_test程序看能捕获到哪些C/A码:
<pre class="lang:default decode:true ">gps_test rtl_2.8Msps_1575.42MHz_1bit.bin 0.62e6 2.8e6 100000</pre>
正常情况下这个程序给出的C/A捕获结果和别人采集时的正确C/A是相同的: <a href="http://www.jks.com/gps/gps.html">http://www.jks.com/gps/gps.html</a>

<strong>1.2 播放/发射我们自己用Matlab脚本generated by gps_sig_gen.m生成的 gps_sig_tmp_for_hackrf_tx.bin</strong>

<strong>a</strong>. GNURadio中运行gps.grc来把gps_sig_tmp_for_hackrf_tx.bin发射至空中. 同时/立刻（或稍提前）,

<strong>b</strong>. 用rtl-sdr电视棒捕获信号:
<pre class="lang:default decode:true "> rtl_sdr -g 60 -f 1574.8e6 -s 2.8e6 -n 19.2e6 rtl_2.8Msps_1574.8MHz.bin</pre>
<strong>c</strong>. 8bit量化文件转回1bit量化，这是我们gps_test程序所需要的：rtl_2.8Msps_1574.8MHz_1bit.bin
<pre class="lang:default decode:true ">proc_rtl_bin_for_gps('rtl_2.8Msps_1574.8MHz.bin'); (MATLAB)</pre>
<strong>d</strong>. 运行:
<pre class="lang:default decode:true ">gps_test rtl_2.8Msps_1574.8MHz_1bit.bin 0.62e6 2.8e6 100000</pre>
正常情况下你会看到程序捕获到的C/A码和我们在Matlab脚本中设置的相同。

<strong>e</strong>. 也可以用不同的载波频率才采集信号（即得到的GPS信号文件中频频率会改变）
<pre class="lang:default decode:true ">rtl_sdr -g 60 -f 1575.42e6 -s 2.8e6 -n 19.2e6 rtl_2.8Msps_1575.42MHz.bin</pre>
<strong>f</strong>. 8bit量化文件转回1bit量化，这是我们gps_test程序所需要的：rtl_2.8Msps_1575.42MHz_1bit.bin
<pre class="lang:default decode:true "> proc_rtl_bin_for_gps('rtl_2.8Msps_1575.42MHz.bin'); (MATLAB)</pre>
<strong>g</strong>. 运行:
<pre class="lang:default decode:true">gps_test rtl_2.8Msps_1575.42MHz_1bit.bin 0.62e6 2.8e6 100000</pre>
正常情况下你会看到程序捕获到的C/A码和我们在Matlab脚本中设置的相同。
